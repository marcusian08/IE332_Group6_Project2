# Libraries
library("tensorflow")
library("keras")
library("magick")
library("foreach")
library("doParallel")
library("plyr")
library("caret")
library(tidyverse)
library(reticulate)
library(imager)

# Load pre-trained model
model=load_model_tf("/Users/Brian Williams/Documents/R/332_data/332_data-main/dandelion_model")

# Initialization
width <- 224
height<- 224
target_size <- c(width, height)
rgb <- 3 #color channels

# Five Algorithms
algorithm1 <- function(image, epsilon) {
  # Implement algorithm here
  return(adversarial_image)
}

algorithm2 <- function(image, epsilon) {
  # Implement algorithm here
  return(adversarial_image)
}

algorithm3 <- function(image, epsilon) {
  # Implement algorithm here
  return(adversarial_image)
}

algorithm4 <- function(image, epsilon) {
  # Implement algorithm here
  return(adversarial_image)
}

algorithm5 <- function(image, epsilon) {
  # Implement algorithm here
  return(adversarial_image)
}

# Default classification
image <- image_load(path, target_size = target_size)
image <- image_to_array(image)
image <- array_reshape(image, c(1, dim(image)))
image <- image/255

pred <- model %>% predict(image) #[1,1] dandelion percentage, [1,2] grass percentage
if (pred[1,1] > .5) {
  trueImageClass <- "Dandelion"
} else {
  trueImageClass <- "Grass"
}

# Five modified images
modImages <- c(algorithm1(image, epsilon), algorithm2(image, epsilon), 
               algorithm3(image, epsilon), algorithm4(image, epsilon), 
               alogirthm5(image, epsilon))

# Create a matrix to hold the predictions of each algorithm for each sample
predictions <- matrix(nrow = 2, ncol = 5)
colnames(predictions) <- c("algorithm1", "algorithm2", "algorithm3", "algorithm4", "algorithm5")

# Fill in the matrix with the predictions of each algorithm
predictions[, "algorithm1"] <- model %>% predict(modImages[1])
predictions[, "algorithm2"] <- model %>% predict(modImages[2])
predictions[, "algorithm3"] <- model %>% predict(modImages[3])
predictions[, "algorithm4"] <- model %>% predict(modImages[4])
predictions[, "algorithm5"] <- model %>% predict(modImages[5])

print(predictions)


#notes (for me): implement a 'successful?' decider that disqualifies algorithms based on pass/fail, take lowest algo

# Assign weights based on each algorithm's performance on the validation data
weights <- algorithm_performances / sum(algorithm_performances)

# Part 4: Implement an optimizer that can select from the set of pixels identified by the five algorithms
optimizer <- function(image, budget_ratio) {
  # Implement an optimizer to select the N most influential pixels or use GA to select the best set of pixels
  return(selected_pixels)
}
